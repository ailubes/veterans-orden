-- Enable pg_trgm extension for fuzzy search (if not already enabled)
CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- Create enums for help system
DO $$ BEGIN
  CREATE TYPE "audience_type" AS ENUM ('all', 'members', 'leaders', 'admins');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE TYPE "article_status" AS ENUM ('draft', 'published', 'archived');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- Create help_categories table
CREATE TABLE IF NOT EXISTS "help_categories" (
  "id" uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  "name_uk" varchar(100) NOT NULL,
  "name_en" varchar(100) NOT NULL,
  "slug" varchar(100) NOT NULL UNIQUE,
  "description" text,
  "icon" varchar(50), -- Lucide icon name
  "parent_id" uuid REFERENCES "help_categories"("id") ON DELETE SET NULL,
  "order" integer DEFAULT 0,
  "is_visible" boolean DEFAULT true,
  "created_at" timestamp DEFAULT now() NOT NULL
);

-- Create help_articles table
CREATE TABLE IF NOT EXISTS "help_articles" (
  "id" uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  "category_id" uuid NOT NULL REFERENCES "help_categories"("id") ON DELETE CASCADE,

  -- Content
  "title" varchar(255) NOT NULL,
  "slug" varchar(255) NOT NULL UNIQUE,
  "content" text NOT NULL,
  "excerpt" text,

  -- Video support
  "video_url" text,

  -- Search (tsvector will be auto-generated by trigger)
  "search_vector" tsvector,
  "keywords" jsonb DEFAULT '[]'::jsonb,

  -- Audience targeting
  "audience" audience_type DEFAULT 'all',

  -- SEO
  "meta_title" varchar(70),
  "meta_description" varchar(160),

  -- Engagement metrics
  "view_count" integer DEFAULT 0,
  "helpful_count" integer DEFAULT 0,
  "not_helpful_count" integer DEFAULT 0,

  -- Publishing
  "status" article_status DEFAULT 'draft',
  "published_at" timestamp,
  "author_id" uuid NOT NULL REFERENCES "users"("id") ON DELETE CASCADE,

  -- Related articles
  "related_article_ids" jsonb DEFAULT '[]'::jsonb,

  "created_at" timestamp DEFAULT now() NOT NULL,
  "updated_at" timestamp DEFAULT now() NOT NULL
);

-- Create help_article_feedback table
CREATE TABLE IF NOT EXISTS "help_article_feedback" (
  "id" uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  "article_id" uuid NOT NULL REFERENCES "help_articles"("id") ON DELETE CASCADE,
  "user_id" uuid REFERENCES "users"("id") ON DELETE SET NULL,
  "is_helpful" boolean NOT NULL,
  "comment" text,
  "created_at" timestamp DEFAULT now() NOT NULL
);

-- Create help_tooltips table
CREATE TABLE IF NOT EXISTS "help_tooltips" (
  "id" uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  "page_slug" varchar(100) NOT NULL,
  "element_id" varchar(100) NOT NULL,
  "content" text NOT NULL,
  "article_id" uuid REFERENCES "help_articles"("id") ON DELETE SET NULL,
  "audience" audience_type DEFAULT 'all',
  "is_active" boolean DEFAULT true,
  "created_at" timestamp DEFAULT now() NOT NULL
);

-- Create indexes for help_categories
CREATE INDEX IF NOT EXISTS "help_categories_parent_idx" ON "help_categories" ("parent_id");
CREATE INDEX IF NOT EXISTS "help_categories_slug_idx" ON "help_categories" ("slug");

-- Create indexes for help_articles
CREATE INDEX IF NOT EXISTS "help_articles_search_idx" ON "help_articles" USING gin("search_vector");
CREATE INDEX IF NOT EXISTS "help_articles_slug_idx" ON "help_articles" ("slug");
CREATE INDEX IF NOT EXISTS "help_articles_category_idx" ON "help_articles" ("category_id");
CREATE INDEX IF NOT EXISTS "help_articles_status_idx" ON "help_articles" ("status");
CREATE INDEX IF NOT EXISTS "help_articles_author_idx" ON "help_articles" ("author_id");
CREATE INDEX IF NOT EXISTS "help_articles_audience_idx" ON "help_articles" ("audience");

-- Create indexes for help_article_feedback
CREATE INDEX IF NOT EXISTS "help_article_feedback_article_idx" ON "help_article_feedback" ("article_id");
CREATE INDEX IF NOT EXISTS "help_article_feedback_user_idx" ON "help_article_feedback" ("user_id");

-- Create indexes for help_tooltips
CREATE UNIQUE INDEX IF NOT EXISTS "help_tooltips_page_element_idx" ON "help_tooltips" ("page_slug", "element_id");
CREATE INDEX IF NOT EXISTS "help_tooltips_article_idx" ON "help_tooltips" ("article_id");

-- Create trigger to auto-update search_vector using 'simple' config (works everywhere)
CREATE OR REPLACE FUNCTION help_articles_search_vector_update()
RETURNS trigger AS $$
BEGIN
  NEW.search_vector :=
    setweight(to_tsvector('simple', coalesce(NEW.title, '')), 'A') ||
    setweight(to_tsvector('simple', coalesce(NEW.content, '')), 'B') ||
    setweight(to_tsvector('simple', coalesce(NEW.excerpt, '')), 'C');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS help_articles_search_vector_trigger ON help_articles;
CREATE TRIGGER help_articles_search_vector_trigger
  BEFORE INSERT OR UPDATE OF title, content, excerpt
  ON "help_articles"
  FOR EACH ROW
  EXECUTE FUNCTION help_articles_search_vector_update();

-- Create function for searching help articles using 'simple' config
CREATE OR REPLACE FUNCTION search_help_articles(
  search_query TEXT,
  max_results INT DEFAULT 20
)
RETURNS TABLE (
  id UUID,
  title VARCHAR,
  excerpt TEXT,
  slug VARCHAR,
  category_name VARCHAR,
  rank REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    a.id,
    a.title,
    a.excerpt,
    a.slug,
    c.name_uk,
    GREATEST(
      -- Title exact match (highest priority)
      CASE WHEN LOWER(a.title) = LOWER(search_query) THEN 1.0 ELSE 0.0 END,
      -- Title contains query
      CASE WHEN LOWER(a.title) LIKE '%' || LOWER(search_query) || '%' THEN 0.8 ELSE 0.0 END,
      -- Full-text search match
      CASE WHEN a.search_vector @@ plainto_tsquery('simple', search_query)
        THEN ts_rank(a.search_vector, plainto_tsquery('simple', search_query)) * 0.6
        ELSE 0.0
      END,
      -- Keywords match
      CASE WHEN a.keywords::text ILIKE '%' || search_query || '%' THEN 0.4 ELSE 0.0 END
    )::real AS rank
  FROM help_articles a
  JOIN help_categories c ON a.category_id = c.id
  WHERE a.status = 'published'
    AND (
      LOWER(a.title) LIKE '%' || LOWER(search_query) || '%'
      OR a.search_vector @@ plainto_tsquery('simple', search_query)
      OR a.keywords::text ILIKE '%' || search_query || '%'
    )
  ORDER BY rank DESC, a.view_count DESC
  LIMIT max_results;
END;
$$ LANGUAGE plpgsql;
